import{_ as e,c as l,o as a,a as t}from"./app.62528036.js";const P=JSON.parse('{"title":"Parcel","titleTemplate":"前言","description":"","frontmatter":{"title":"Parcel","titleTemplate":"前言"},"headers":[],"relativePath":"_NOTES/Build Tools/parcel/01_pre.md","lastUpdated":1672992558000}'),r={name:"_NOTES/Build Tools/parcel/01_pre.md"},o=t('<h1 id="parcel" tabindex="-1">Parcel <a class="header-anchor" href="#parcel" aria-hidden="true">#</a></h1><p><a href="https://v2.parceljs.cn/" target="_blank" rel="noreferrer">Parcel</a> 是一个零配置的构建工具。</p><p>但是, 零配置就真的好嘛?</p><p>零配置实际就是为各种各样的场景填充默认值, 虽然能节省很多工作量, 但是毫无疑问也会带来一系列问题：</p><ul><li>不讲武德的 node_modules</li></ul><p>被依赖的库的文件是不可控的, 取决于开发者, NPM 平台并没有强制包的规范, 比如可能把 <code>.babelrc</code> 文件也发布至了 NPM。</p><p>而 Parcel 只要在目录中发现这些配置文件就会认为该项目中的代码需要被处理, 就可能出现本来是 ES5 代码还要经过 Babel 转译一遍的情况, 浪费性能。</p><ul><li>成也零配置败也零配置</li></ul><p>零配置意味着：</p><ol><li>无法控制对部分文件的特殊处理</li><li>无法控制输出文件名的 hash 值和名称</li><li>无法控制构建输出目录结构</li><li>无法映射路径别名</li><li>不支持 History API</li></ol><blockquote><p>不可控有时候是非常讨厌的。</p></blockquote><hr><p>Parcel 的生态、报错信息不够全面等都是它的硬伤。</p><p>但是 Parcel 也不是一无是处, 简单的实验性 demo 使用它还是非常好的, 不用配置。</p><blockquote><p>如有需要再翻看官网吧。</p></blockquote>',15),p=[o];function c(i,_,s,d,n,u){return a(),l("div",null,p)}const m=e(r,[["render",c]]);export{P as __pageData,m as default};
